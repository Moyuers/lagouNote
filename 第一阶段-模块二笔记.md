# 模块二、Java面向对象编程

# 一、类和对象

## 1.面向对象编程的概念（核心）

**对象：**万物皆对象。客观存在的实体。

**面向对象：**以特征（属性）和行为（方法）的观点去分析现实生活中的事物。

**面向对象编程：**以面向对象思想进行分析，再用面向对象编程语言进行表达。是软件产业化发展的需求。

## 2.类和对象的概念

**Java中的对象：**体现为内存空间中的一块存储区域。（堆区）

**类：**分类。具有相同特征和行为的多个对象共性的抽象描述。是用来构建对象的模板，对象的数据结构由定义它的类决定。

**Java中的类：**一种引用数据类型，包含描述属性的成员变量和描述行为的成员方法。

## 3.相关定义

```java
//类定义
class 类名{
	类体;
	数据类型 成员变量名 = 初始值;//成员变量定义
	//成员方法定义
	返回值类型 成员方法名(形参列表){
		成员方法体;
	}
}
```

**命名规范：**

**类名：**由多个单词组成每个单词首字母都大写。

**成员变量名：**由多个单词组成从第二个单词起每个单词的首字母大写。

**成员方法名：**同成员变量。

```java
new 类名();//创建对象，没给名字的对象称做匿名对象
```

**类的实例化：**使用new关键字创建该类的对象。

创建对象的本质：在堆区申请一块存储区域，用于存放该对象独有的特征信息。

**返回值：**方法体内返回到方法体外的数据内容。方法体中使用return关键字返回具体的数据内容并结束当前方法。不返回数据则返回类型为**void**。

**形参列表：形参**将方法体外的数据内容带入到方法体内。形参列表指多个形式参数组成的列表。

数据类型 形参变量1,数据类型 形参变量2,…

### 引用

**引用：**使用引用数据类型定义的变量，记录对象在堆区中的内存地址信息，方便之后的访问。

```java
类名 引用变量名;
引用变量名.成员变量名;//访问成员变量
引用变量名.成员方法名(实参列表);//访问成员方法
```

实参列表对形参列表进行初始化，实参列表的数量、类型及顺序都要一致。

实参可以传递直接量、变量、表达式、方法的调用等。

### 可变长参数

```java
返回值类型 方法名(参数的类型… 参数名)
```

可传0~n个实参。

一个方法的形参列表中最多只能声明一个可变长形参，且需要放到参数列表的末尾。

## 4.方法的传参

### 传参过程

1. 为实参分配空间并初始化
2. 调用方法，为形参分配空间
3. 将实参的值赋值到形参的内存空间中
4. 方法执行完毕后，形参空间释放
5. 方法的返回值的值赋值给结果变量

### 注意事项

- 基本数据变量：形参的值在方法中的改变不会改变实参的值（不同的内存空间）
- 引用数据变量：形参的值在方法中的改变会改变实参的值（地址相同，指向同一块堆区）
- 栈区：用于存放程序运行过程中所有的局部变量。JVM会为每一个方法的调用在栈中分配一个对应的空间，称为该方法的**栈帧**。一个栈帧对应一个正在调用中的方法，其中存储了该方法的参数、局部变量等。

## 5.总结Summary

- 面向对象的概念
    - 对象
    - 面向对象
    - 面向对象编程（封装、继承、多态）
- **类和对象的概念**
    - 类和对象
    - 类的定义
    - 成员变量的定义
    - 对象的创建（实例化）
    - 引用的定义
- 成员方法
    - 语法格式
    - 详解
    - 调用格式
    - 传参的过程及注意事项

# 二、方法和封装

## 1.构造方法

```java
class 类名{
	类名(形参列表){
		构造方法体;	
	}
}
```

**概念：**方法名和类名相同且无返回值类型。在创建对象时调用

### 默认/缺省构造方法

类中未定义任何构造方法时，编译器自动添加一个无参空构造方法。

若类中出现了构造方法，则编译器不会提供任何形式的构造方法。

### 作用

使用new关键字创建对象时同时自动调用构造方法实现成员变量的初始化。

## 2.重载

方法名相同但参数列表不同的方法之间构成重载关系（Overload）

### 体现形式

1. 参数个数不同；
2. 参数类型不同；
3. 参数顺序不同；
4. 与参数变量名无关；
5. 与返回值类型无关；

**核心：**调用时是否能区分

### 实际意义

对于调用者只需要记住一个方法名就可调用各种不同的版本。

## 3.this关键字

### 基本概念

在构造方法中出现了this关键字，代表正在构造的对象。

在成员方法中出现了this关键字，代表正在调用的对象。

**this关键字本质上是当前类类型的引用变量。**

### 工作原理

构造方法和成员方法访问成员变量时隐含了this关键字（编译器自动补充）。

### 使用方式

1. 局部变量名与成员变量名一样时，优先使用局部变量，因此成员变量用this.前缀以区分；
2. this还可以作为方法的返回值；
3. 在构造方法的第一行可以使用this()的方式来调用本类中的其他构造方法。

引用变量的数值可以为空。当空的引用变量需要输出成员变量时发生**NullPointerException空指针异常。**

## 4.递归

- 使用递归必须有递归的规律以及退出条件；
- 必须使问题简单化而不是复杂化；
- 若递归影响到程序的执行性能，则使用递推取代。

## 5.封装

**概念：**为了避免测试类给成员变量一些合法但不合理的数值，需要对成员变量进行包装处理，来隐藏成员变量的细节以及保证成员变量数值的合理性。

### 实现流程

1. 私有化成员变量，使用private关键字修饰（该成员变量只能在当前类的内部使用）；
2. 提供公有的（public修饰，可以在任意位置使用）get和set方法，并在方法体中进行合理值的判断；（无修饰符是默认的访问权限，级别介于private和public之间）
3. 在构造方法中调用set方法进行合理值判断；

### JavaBean(可重用组件)

其他Java类可以通过反射机制发现和操作这些JavaBean的属性。

1. 类是公共的；
2. 有一个无参的公共的构造器；
3. 有属性，且有对应的get、set方法。

## 6.总结Summary

- **构造方法**
    - 语法形式
    - 默认构造方法
    - 实现成员变量的初始化
- 方法重载
    - 概念
    - 体现形式
    - 实际意义
- this关键字
    - 概念
    - 原理
    - 使用方法
- 递归
    - 概念
    - 使用原则
- **封装**
    - 概念
    - 实现流程

# 三、static关键字和继承

## 1.static关键字

### 基本概念

修饰成员变量代表静态含义。此时成员变量由对象层级提升为类层级（整个类只有一份并被所有对象共享），该成员变量随着类的加载准备就绪，与是否创建对象无关（类名.成员变量 访问）。

### 使用方式

1. 非静态成员方法中既可以访问非静态成员又能访问静态成员；（静态对象被所有对象共享）
2. 静态成员方法中只能访问静态成员；（此时不一定创建了对象）
3. **不滥用：**开发中只有隶属于类层级并被所有对象共享的内容才可以使用static关键字修饰。

### 构造块&静态代码块

**构造块：**在类体中直接使用{}括起来的代码块。

需要在执行构造方法体之前做准备工作时，将相关代码放入构造块中，比如对成员变量进行统一的初始化的操作。

每创建一个对象都会执行一次构造块。

**静态代码块：**用static修饰的构造块。（会随着类的加载而准备就绪，只执行一次，先于构造块执行）

需要在执行代码块之前随着类的加载做准备工作时，比如：加载数据库的驱动包等。

**执行顺序：**静态代码块→构造块→构造方法体（父类静态→子类静态→父类构造块→父类构造方法体→子类构造块→子类构造方法体）

## 2.main方法

```java
public static void main(String[] args){}
```

可在运行时传参：java 类名 参数列表

### 3.单例模式

**单例类：**对外提供且只提供一个对象的类；

**实现流程：**

1. 私有化构造方法；private
2. 声明本类类型的引用指向本类类型的对象，使用private static修饰；
3. 提供公有的get方法负责将对象返回出去，使用public static修饰。

**饿汉式单例模式：**

```java
private static Singleton sin = new Singleton();
public static Singleton getInstance(){
	return sin;
}
```

**懒汉式单例模式：**

```java
private static Singleton sin = null;
public static Singleton getInstance(){
	if(null==sin){
		sin = new Singleton();
	}
	return sin;
}
```

一般无特殊要求推荐饿汉式

## 4.继承

### 概念

extends关键字表示继承关系

被继承的类：**超类、父类、基类**

继承类：**子类、派生类、孩子类**

使用继承能够提高代码的复用性、可维护性和扩展性，是多态的前提条件。

### 特点

- 子类不能继承父类的构造方法和私有方法，但私有成员变量可以被继承只是不能直接访问；
- 构造子类的对象总会自动调用父类的无参构造方法（初始化父类中继承的成员变量，相当于在构造方法的第一行增加super()的效果）；
- 必须满足逻辑关系：子类 is a 父类（子类一定可以看作一个父类）
- Java中子类只能有一个父类，父类可以有多个子类。

## 5.重写

**重写（Override）：**子类继承父类中的方法不满足子类的需求时，需要在子类中重新写一个和父类一样的方法以覆盖方法。

### 原则

- 方法名相同、参数列表相同以及返回值类型相同（Java 5允许返回子类类型）
- 访问权限不能变小，可以相同或变大
- 不能抛出更大的异常

## 6.权限修饰符

[访问控制符](https://www.notion.so/5577fca8517a4dbfbaf08e9fb7a5ceae)

public修饰的成员在任意位置使用，private只能在本类。

通常成员方法都用public，成员变量都用private。

### 包package

避免出现类名冲突、实现项目管理、便于权限控制。

**定义：**

```java
package 包名;
package 包名1.包名2...包名n;
```

**规范：**公司或组织域名.项目名.模块名.类名

**导入：**import关键字导入包（5.0后导入静态成员）

### final修饰符

**修饰类**：不能被继承（防止滥用继承，比如java.lang.String）

**修饰成员方法：**方法不能被重写可以被继承

**修饰成员变量：**该成员变量必须被初始化且不能更改（直接初始化、构造块中初始化、构造方法体中初始化）

### 常量

public static final修饰。

命名规范：所有字母都大写。

## 7.Summary总结

- static关键字
    - 概念
    - 使用方法
    - 构造块和静态代码块
    - 单例设计模式
        - 饿汉式
        - 懒汉式
- 继承
    - 概念
    - 特点
    - 方法重写
    - 重写原则
    - IDEA使用
- 访问控制
    - public
    - private
    - package
    - 导入
- final关键字
    - 概念
    - 修饰类
    - 修饰成员方法
    - 修饰成员变量
    - 常量

# 四、多态和特殊类

## 1.多态

同一种事物表示出来的多种形态。

Java中：父类引用指向子类对象的形式。

**语法格式：**

父类类型 引用变量名= new 子类类型();

### 特点：

- 父类类型的引用指向子类对象时，引用可以直接调用父类独享的方法；
- 父类类型的引用指向子类对象时，引用不可以直接调用子类独享的方法；
- **动态绑定：**对于父子类都有的非静态方法来说，编译阶段调用父类版本，运行阶段调用子类重写的版本。
- 对于父子都有的静态方法，编译和运行阶段都用父类方法。
- 父类引用想调用子类独享的方法，用强制类型转换

### 意义：

屏蔽不同子类的差异性实现通用的编程带来不同的效果。

## 2.引用数据转换

自动转：子类转父类，小到大，向上转型

强制转：父类转子类，大到小，向下转型

**注意事项：**

必须拥有父子类关系

若强转的目标类型不是引用真正指向的数据类型时编译通过，运行发生ClassCastException异常。

为了避免强转错误的发生，应该在强转之前进行判断：

```java
if(引用变量 instanceof 数据类型)//判断引用变量指向的对象是否为后面的数据类型
```

## 2.抽象

### 抽象方法

不能具体实现的方法：abstract关键字修饰，没有方法体。

```java
访问权限 abstract 返回值类型 方法名(形参列表);
```

### 抽象类

不能具体实例化（创建对象）的类：abstract修饰，真正的抽象类应该具有抽象方法

### 抽象类和抽象方法的关系

- 抽象类中可以有成员变量、成员方法、构造方法
- 抽象类中有无抽象方法都行
- 一个类中有抽象方法该类必须是抽象类

### 意义

在于被继承，提供一个模板让子类去具体实现。

一个类继承抽象类后必须重写抽象方法，抽象类对子类具有强制性和规范性。（模板设计模式）

abstract和final、static、private不能共存

## 3.接口

### 基本概念

接口中的所有方法都是抽象方法，且只能有常量。（jdk1.9之后允许接口中出现私有方法）

**interface：**定义接口的关键字

### 实际意义：实现多继承

### 接口和类之间的关系

1. 类与类：单继承，extends
2. 类与接口：多实现，implements
3. 接口与接口：多继承，extends

### 抽象类和接口的区别

1. 定义关键字不同：abstract class\interface
2. 继承关键字不同：extends\implements
3. 抽象类单继承，接口多实现
4. 抽象类中可以有构造方法而接口中不可以有
5. 抽象类中可以有成员变量而接口中只可以有常量
6. 抽象类中可以有成员方法而接口中只可以有抽象方法
7. 抽象类中增加方法子类可以不用重写，而接口中增加方法时实现类需要重写（Java8以前）
8. Java8开始接口中允许非抽象方法和静态方法，但非抽象方法需要使用default关键字修饰，静态方法直接用接口名.方法调用
9. Java9开始接口中允许出现私有方法

## 4.Summary总结

- **多态**
    - 基本概念
    - 语法格式
    - 特点
    - 引用类型转换
        - 原则
        - 判断instanceof
    - 实际意义
- 抽象
    - 抽象方法
    - 抽象类
    - 抽象类和方法的关系
    - 实际意义
- 接口
    - 基本概念
    - 常量
    - 抽象方法
    - 接口和类的关系
    - 接口和抽象类的区别（Jdk8、9的新特性）

# 五、特殊类

## 1.内部类（Inner）

一个类的定义出现在另一个类的类体中时，该类叫做内部类，这个类所在的类叫外部类（Outer）；

**类中的内容：**成员变量、成员方法、构造方法、静态成员、构造块和静态代码块、内部类。

**存在意义：**一个类存在仅为某一个类单独服务时，就可以将这个类定义为所服务类中的内部类。能够隐藏该类的实现细节，且在访问外部类的私有成员时不需要公有的get和set方法。

### 分类

**普通内部类**：直接定义一个类于另一个类中

**静态内部类：**用static修饰

**局部内部类：**定义在方法体内部

**匿名内部类**：没有名字的内部类

### 普通内部类

```java
访问修饰符 class 外部类{
	访问修饰符 class 内部类{
		内部类的类体;
	}
}
```

**使用方式**

- 可以定义成员变量、成员方法及构造方法等；
- 可以使用final或abstract关键字修饰
- 可以使用private或protected修饰
- 需要使用外部类对象来创建对象
- 内部类访问与外部类成员变量同名的成员变量时，需要使用this关键字

### 静态内部类

```java
访问修饰符 class 外部类{
	访问修饰符 static class 内部类{
		内部类的类体;
	}
}
```

**使用方式**

- 能不能访问外部类的非静态成员
- 可以直接创建对象
- 访问外部类中与本类内同名的成员变量或方法时，需要使用类名.方式使用

### 局部内部类

```java
访问修饰符 class 外部类{
	访问修饰符 返回值类型 成员方法名(参数列表){
		class 内部类{
			内部类的类体;
		}
	}
}
```

**使用方式：**

- 只能在该方法的内部使用
- 可以在方法体内直接创建对象
- 不能使用访问控制符和static关键字修饰符
- 可以使用外部方法的局部变量，但必须是用final修饰的。（局部内部类和局部变量的声明周期不同）

### 回调模式

一个方法的参数是接口类型，则在调用该方法时需要创建并传递一个实现此接口类型的对象；而该方法在运行时会调用到参数对象中所实现的方法（由接口定义）

### 匿名内部类

```java
接口/父类类型 引用变量名 = new 接口/父类类型(){方法的重写};
```

Lamda表达式：(参数列表)- >{方法体}

## 2.枚举类

能够一一列举出来的事物。

采用enum关键字来定义枚举类型取代常量。

枚举值就是当前类的类型，也就是指向本类的对象，默认使用public static final关键字共同修饰，采用枚举类型.的方式调用。

枚举类可以自定义构造方法，但是构造方法的修饰符必须是private，默认也是私有的。

枚举类不能继承其他类，可以实现接口，重写接口的抽象方法的方式：只重写一次、每个对象都重写。

### Enum类

所有的枚举类都继承自java.lang.Enum类。

**常用方法：**

- static T[] values() 返回当前枚举类中的所有对象
- String toString() 返回当前枚举类对象的名称（打印引用变量时，会自动调用toString方法。）
- int ordinal() 获取枚举对象在枚举类中的索引位置
- static T valueOf(String str) 将参数指定的字符串名转为当前枚举类的对象（字符串名称必须在枚举对象中存在）
- int compareTo(E o) 比较两个枚举对象在定义时的顺序（正数：调用对象在参数对象之后；0：调用对象和参数对象位置相同；）

## 3.注解（Annotation）

### 概念

标注，Java5增加的一种引用数据类型。

本质上是代码中的特殊标记，通过这些标记可以在编译、类加载、以及运行时执行指定的处理。

### 语法格式

```java
访问修饰符 @interface 注解名称{
	注解成员;
}
```

自定义注解自动继承java.lang.annotation.Annotation接口

使用注解时：@注解名称，修饰包、类、成员方法、成员变量、构造方法、参数、局部变量的声明等。

**标记注解：**一个注解中没有任何成员

注解体中只有成员变量没有成员方法，成员变量以“无形参的方式”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。

如果注解只有一个参数成员，建议使用参数名为**value，**而类型只能是八种基本数据类型、String、Class、enum及Annotation

成员变量小括号后跟 default 默认值，给予成员变量初始值。

### 元注解

可以注解到注解上的注解，基本注解，能够应用到其他注解上。

**@Retention：**说明该注解的生命周期，取值：

RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。

RetentionPolicy.CLASS 注解只保留到编译进行，不会加载到JVM中，默认方式。

RetentionPolicy.RUNTIME 保留到程序运行时，会被加载入JVM，程序运行时也可以获取。

**@Documented：**

javadoc工具抽取形成API文档，默认不抽取注释，但用@Documented注解的注解会抽取。

**@Target：**用于被修饰的注解能用于哪些元素的修饰，取值（可以多个取值放入大括号）：

[@Target 注解取值](https://www.notion.so/773d7ae5615a41b3ad429eade310844e)

**@Inherited：**超类被Inherited标记的注解标记时，如果子类没有被任何注解应用时，则子类就继承超类的注解。

**@Repeatable：**自然可重复

### 常见的预制注解

[预制注解](https://www.notion.so/bdb3dc0796174aed89faba4e0bce7266)

## 4.Summary总结

- 内部类
    - 概念
    - 分类
        - 普通内部类
        - 静态内部类
        - 局部内部类
        - **匿名内部类**
    - 回调模式
- 枚举
    - 概念
    - 自定义枚举类
    - enum关键字
    - Enum类
    - 实现接口
- 注解
    - 概念
    - 自定义注解
    - 元注解
    - 预制注解